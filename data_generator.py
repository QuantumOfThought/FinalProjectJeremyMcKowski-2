import random
from faker import Faker
from datetime import datetime

# Step 1: Initialize Faker
# We use Faker to generate realistic-looking data like MAC addresses and IPs.
fake = Faker()


class NetworkTrafficGenerator:
    def __init__(self):
        """
        Initialize the generator with specific network devices.

        IMPORTANT: MAC addresses are generated ONCE during initialization and remain static.
        This simulates real hardware where MAC addresses are burned into the network interface
        and never change. If we generated them on every call to fake.mac_address(), they would
        change each time the class is instantiated, which is unrealistic.

        Connection types (Wired/Wi-Fi) are assigned based on typical device usage patterns:
        - Routers and Desktops are typically hardwired via Ethernet
        - Mobile devices (phones) use Wi-Fi
        - Printers can be either, but we'll make this one Wi-Fi for variety
        """

        # Step 2A: Generate static MAC addresses for each device
        # These MAC addresses will remain constant for the lifetime of this generator instance
        # This ensures device identity consistency - just like real network hardware
        router_mac = fake.mac_address()  # e.g., "aa:bb:cc:dd:ee:ff"
        desktop_mac = fake.mac_address()  # Each device gets a unique MAC
        iphone_mac = fake.mac_address()  # MACs are 6 pairs of hex digits
        printer_mac = fake.mac_address()  # Separated by colons
        android_mac = fake.mac_address()  # Generated by Faker to look realistic

        # Step 2B: Define our static devices
        # We are creating a list of dictionaries, where each dictionary represents a device.
        # Each device has properties that describe its current state and identity.
        self.devices = [
            {
                # Device 1: The Router (Ubiquiti Dream Machine)
                # This is the central hub of the network - all traffic flows through it
                "name": "Ubiquiti Dream Machine",
                "type": "Router",
                "ip": "192.168.1.1",  # Standard gateway IP
                "mac": router_mac,  # Use the static MAC we generated above
                "connection_type": "Wired",  # Routers are hardwired to the modem
                "status": "ONLINE",  # Router should always be online
                "upload_bytes": 0,  # Cumulative upload traffic in bytes
                "download_bytes": 0,  # Cumulative download traffic in bytes
                "last_seen": datetime.now().strftime("%Y-%m-%d %H:%M:%S")  # Timestamp of last activity
            },
            {
                # Device 2: Desktop Computer
                # Desktop computers are typically connected via Ethernet for speed/stability
                "name": "Home Desktop PC",
                "type": "Desktop",
                "ip": "192.168.1.15",  # Static IP in the local subnet
                "mac": desktop_mac,  # Static MAC address for this device
                "connection_type": "Wired",  # Desktops usually use Ethernet cables
                "status": "ONLINE",
                "upload_bytes": 0,
                "download_bytes": 0,
                "last_seen": datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            },
            {
                # Device 3: iPhone (Mobile Device)
                # Phones connect wirelessly and may go offline when the user leaves
                "name": "User iPhone",
                "type": "Mobile",
                "ip": "192.168.1.22",  # DHCP-assigned IP
                "mac": iphone_mac,  # Unique MAC for this phone
                "connection_type": "Wi-Fi",  # Mobile devices connect wirelessly
                "status": "ONLINE",
                "upload_bytes": 0,
                "download_bytes": 0,
                "last_seen": datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            },
            {
                # Device 4: Network Printer
                # Printers often go to sleep/offline and can connect via Wi-Fi
                "name": "Home Printer",
                "type": "Printer",
                "ip": "192.168.1.50",  # Static IP for printer discovery
                "mac": printer_mac,  # Static MAC for this printer
                "connection_type": "Wi-Fi",  # Modern printers often use wireless
                "status": "OFFLINE",  # Starts offline (powered off/sleeping)
                "upload_bytes": 0,
                "download_bytes": 0,
                "last_seen": datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            },
            {
                # Device 5: Guest Android Phone
                # Guest devices may connect/disconnect frequently
                "name": "Guest Android",
                "type": "Mobile",
                "ip": "192.168.1.23",  # Guest network DHCP
                "mac": android_mac,  # Unique MAC for this phone
                "connection_type": "Wi-Fi",  # Guests connect wirelessly
                "status": "ONLINE",
                "upload_bytes": 0,
                "download_bytes": 0,
                "last_seen": datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            }
        ]

    def _simulate_traffic(self):
        """
        Internal method to simulate traffic changes and connection status.
        """
        for device in self.devices:
            # Randomly toggle status for Printer and Android
            if device["name"] in ["Home Printer", "Guest Android"]:
                # 10% chance to flip status
                if random.random() < 0.1:
                    if device["status"] == "ONLINE":
                        device["status"] = "OFFLINE"
                    else:
                        device["status"] = "ONLINE"
                        # Reset timestamp when coming online
                        device["last_seen"] = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

            # Only generate traffic if ONLINE
            if device["status"] == "ONLINE":
                if device["type"] == "Router":
                    added_upload = random.randint(1000, 5000000)
                    added_download = random.randint(5000, 10000000)
                elif device["type"] == "Printer":
                    added_upload = random.randint(0, 1000)
                    added_download = random.randint(0, 1000)
                else:
                    added_upload = random.randint(100, 1000000)
                    added_download = random.randint(500, 5000000)

                device["upload_bytes"] += added_upload
                device["download_bytes"] += added_download

                # Update timestamp while active
                device["last_seen"] = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    def get_devices(self):
        """
        Public method to get the current state of devices.
        Triggers a traffic simulation update before returning.
        """
        # Step 4: Update traffic before returning data
        self._simulate_traffic()
        return self.devices

    def generate_external_connections(self):
        """
        Generates random external connections for the map visualization.
        Weighted by country as requested:
        - 50% US
        - 10% China
        - 10% Russia
        - 30% EU
        """
        connections = []
        # Generate a random number of active connections (e.g., 10-20)
        num_connections = random.randint(10, 20)

        for _ in range(num_connections):
            r = random.random()

            if r < 0.5:
                # US (Approx Center: 37, -95)
                lat = 37.0 + random.uniform(-10, 10)
                lon = -95.0 + random.uniform(-20, 20)
            elif r < 0.6:
                # China (Approx Center: 35, 104)
                lat = 35.0 + random.uniform(-5, 5)
                lon = 104.0 + random.uniform(-10, 10)
            elif r < 0.7:
                # Russia (Approx Center: 61, 105)
                lat = 61.0 + random.uniform(-10, 10)
                lon = 105.0 + random.uniform(-20, 20)
            else:
                # EU (Approx Center: 50, 10)
                lat = 50.0 + random.uniform(-5, 10)
                lon = 10.0 + random.uniform(-10, 20)

            connections.append({
                "lat": lat,
                "lon": lon
            })

        return connections