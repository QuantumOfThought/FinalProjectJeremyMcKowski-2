# =============================================================================
# NETWORK TRAFFIC GENERATOR MODULE
# =============================================================================
# INF601 - Advanced Programming in Python
# Jeremy McKowski
# Final Project
#
# NOTE: I did use Claude to help clean up my messy comments, check for grammar,
# and better format it for demo.

import random
from faker import Faker
from datetime import datetime, timedelta

# Step 1: Initialize Faker
# We use Faker to generate realistic-looking data like MAC addresses and IPs.
fake = Faker()


class NetworkTrafficGenerator:
    def __init__(self):
        """
        Initialize the generator with specific network devices.

        IMPORTANT: MAC addresses are generated ONCE during initialization and remain static.
        This simulates real hardware where MAC addresses are burned into the network interface
        and never change. If we generated them on every call to fake.mac_address(), they would
        change each time the class is instantiated, which is unrealistic.

        Connection types (Wired/Wi-Fi) are assigned based on typical device usage patterns:
        - Routers and Desktops are typically hardwired via Ethernet
        - Mobile devices (phones) use Wi-Fi
        - Printers can be either, but we'll make this one Wi-Fi for variety
        """

        # Step 2A: Generate static MAC addresses for each device
        # These MAC addresses will remain constant for the lifetime of this generator instance
        # This ensures device identity consistency - just like real network hardware
        router_mac = fake.mac_address()  # e.g., "aa:bb:cc:dd:ee:ff"
        desktop_mac = fake.mac_address()  # Each device gets a unique MAC
        iphone_mac = fake.mac_address()  # MACs are 6 pairs of hex digits
        printer_mac = fake.mac_address()  # Separated by colons
        android_mac = fake.mac_address()  # Generated by Faker to look realistic

        # Step 2B: Define our static devices
        # We are creating a list of dictionaries, where each dictionary represents a device.
        # Each device has properties that describe its current state and identity.
        self.devices = [
            {
                # Device 1: The Router (Ubiquiti Dream Machine)
                # This is the central hub of the network - all traffic flows through it
                "name": "Ubiquiti Dream Machine",
                "type": "Router",
                "ip": "192.168.1.1",  # Standard gateway IP
                "mac": router_mac,  # Use the static MAC we generated above
                "connection_type": "Wired",  # Routers are hardwired to the modem
                "status": "ONLINE",  # Router should always be online
                "upload_bytes": 0,  # Cumulative upload traffic in bytes
                "download_bytes": 0,  # Cumulative download traffic in bytes
                "last_seen": datetime.now().strftime("%Y-%m-%d %H:%M:%S")  # Timestamp of last activity
            },
            {
                # Device 2: Desktop Computer
                # Desktop computers are typically connected via Ethernet for speed/stability
                "name": "Home Desktop PC",
                "type": "Desktop",
                "ip": "192.168.1.15",  # Static IP in the local subnet
                "mac": desktop_mac,  # Static MAC address for this device
                "connection_type": "Wired",  # Desktops usually use Ethernet cables
                "status": "ONLINE",
                "upload_bytes": 0,
                "download_bytes": 0,
                "last_seen": datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            },
            {
                # Device 3: iPhone (Mobile Device)
                # Phones connect wirelessly and may go offline when the user leaves
                "name": "User iPhone",
                "type": "Mobile",
                "ip": "192.168.1.22",  # DHCP-assigned IP
                "mac": iphone_mac,  # Unique MAC for this phone
                "connection_type": "Wi-Fi",  # Mobile devices connect wirelessly
                "status": "ONLINE",
                "upload_bytes": 0,
                "download_bytes": 0,
                "last_seen": datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            },
            {
                # Device 4: Network Printer
                # Printers often go to sleep/offline and can connect via Wi-Fi
                "name": "Home Printer",
                "type": "Printer",
                "ip": "192.168.1.50",  # Static IP for printer discovery
                "mac": printer_mac,  # Static MAC for this printer
                "connection_type": "Wi-Fi",  # Modern printers often use wireless
                "status": "OFFLINE",  # Starts offline (powered off/sleeping)
                "upload_bytes": 0,
                "download_bytes": 0,
                "last_seen": datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            },
            {
                # Device 5: Guest Android Phone
                # Guest devices may connect/disconnect frequently
                "name": "Guest Android",
                "type": "Mobile",
                "ip": "192.168.1.23",  # Guest network DHCP
                "mac": android_mac,  # Unique MAC for this phone
                "connection_type": "Wi-Fi",  # Guests connect wirelessly
                "status": "ONLINE",
                "upload_bytes": 0,
                "download_bytes": 0,
                "last_seen": datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            }
        ]

    def _simulate_traffic(self):
        """
        Internal method to simulate traffic changes and connection status.
        """
        for device in self.devices:
            # Randomly toggle status for Printer and Android ## used claude to help with this part, as I could not get it to work
            if device["name"] in ["Home Printer", "Guest Android"]:
                # 10% chance to flip status
                if random.random() < 0.1:
                    if device["status"] == "ONLINE":
                        device["status"] = "OFFLINE"
                    else:
                        device["status"] = "ONLINE"
                        # Reset timestamp when coming online
                        device["last_seen"] = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

            # Only generate traffic if ONLINE
            if device["status"] == "ONLINE":
                if device["type"] == "Router":
                    added_upload = random.randint(1000, 5000000)
                    added_download = random.randint(5000, 10000000)
                    # Router has higher throughput speeds
                    device["current_upload_speed"] = random.uniform(0.5, 10.0)  # MB/s
                    device["current_download_speed"] = random.uniform(2.0, 50.0)  # MB/s
                elif device["type"] == "Printer":
                    added_upload = random.randint(0, 1000)
                    added_download = random.randint(0, 1000)
                    # Printer has minimal speeds
                    device["current_upload_speed"] = random.uniform(0.0, 0.5)  # MB/s
                    device["current_download_speed"] = random.uniform(0.0, 0.5)  # MB/s
                else:
                    added_upload = random.randint(100, 1000000)
                    added_download = random.randint(500, 5000000)
                    # Other devices (desktops, mobile) have moderate speeds
                    device["current_upload_speed"] = random.uniform(0.1, 5.0)  # MB/s
                    device["current_download_speed"] = random.uniform(0.5, 25.0)  # MB/s

                device["upload_bytes"] += added_upload
                device["download_bytes"] += added_download

                # Update timestamp while active
                device["last_seen"] = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            else:
                # Offline devices have 0 speed
                device["current_upload_speed"] = 0.0
                device["current_download_speed"] = 0.0

    def get_devices(self):
        """
        Public method to get the current state of devices.
        Triggers a traffic simulation update before returning.
        """
        # Step 4: Update traffic before returning data
        self._simulate_traffic()
        return self.devices

    def generate_external_connections(self):
        """
        Generates random external connections for the map visualization.
        Weighted by country as requested:
        - 50% US
        - 10% China
        - 10% Russia
        - 30% EU
        """
        connections = []
        # Generate a random number of active connections (e.g., 10-20)
        num_connections = random.randint(10, 20)

        for _ in range(num_connections):
            r = random.random()

            if r < 0.5:
                # US (Approx Center: 37, -95)
                lat = 37.0 + random.uniform(-10, 10)
                lon = -95.0 + random.uniform(-20, 20)
            elif r < 0.6:
                # China (Approx Center: 35, 104)
                lat = 35.0 + random.uniform(-5, 5)
                lon = 104.0 + random.uniform(-10, 10)
            elif r < 0.7:
                # Russia (Approx Center: 61, 105)
                lat = 61.0 + random.uniform(-10, 10)
                lon = 105.0 + random.uniform(-20, 20)
            else:
                # EU (Approx Center: 50, 10)
                lat = 50.0 + random.uniform(-5, 10)
                lon = 10.0 + random.uniform(-10, 20)

            connections.append({
                "lat": lat,
                "lon": lon
            })

        return connections

    def generate_security_alerts(self):
        """
        Generates simulated suspicious traffic alerts.
        Returns a list of alert dictionaries or empty list if no alerts this cycle.

        Alert types:
        - Port scans from risky IPs
        - Connections to high-risk countries
        - Data exfiltration (large uploads to unknown IPs)
        - Unusual port access (SSH, database ports)
        """
        alerts = []

        # 20% chance to generate an alert on each call
        if random.random() > 0.2:
            return alerts

        # Randomly pick number of alerts (1-2)
        num_alerts = random.randint(1, 2)

        # Get list of online devices
        online_devices = [d for d in self.devices if d['status'] == 'ONLINE']

        if not online_devices:
            return alerts

        for _ in range(num_alerts):
            # Pick a random online device
            device = random.choice(online_devices)

            # Determine alert type
            alert_type = random.choice([
                'port_scan',
                'risky_geo',
                'data_exfiltration',
                'unusual_port'
            ])

            # Generate external IP based on alert type
            if alert_type == 'risky_geo':
                # Generate IP from risky countries
                country = random.choice(['China', 'Russia', 'North Korea', 'Iran'])
                external_ip = fake.ipv4_public()
                reason = f"Connection from {country}"
                severity = "High"

            elif alert_type == 'port_scan':
                # Port scanning activity
                external_ip = fake.ipv4_public()
                ports = random.choice([
                    "22, 23, 80, 443, 3389",
                    "21, 22, 3306, 5432",
                    "135, 139, 445, 3389"
                ])
                reason = f"Port scan detected (ports: {ports})"
                severity = "Medium"

            elif alert_type == 'data_exfiltration':
                # Large data upload
                external_ip = fake.ipv4_public()
                data_size = random.randint(500, 2000)
                reason = f"Large upload detected ({data_size} MB to unknown IP)"
                severity = "High"

            else:  # unusual_port
                # Unusual port access
                external_ip = fake.ipv4_public()
                port = random.choice([22, 23, 3389, 3306, 5432, 27017, 6379])
                port_name = {
                    22: "SSH",
                    23: "Telnet",
                    3389: "RDP",
                    3306: "MySQL",
                    5432: "PostgreSQL",
                    27017: "MongoDB",
                    6379: "Redis"
                }
                reason = f"Unexpected {port_name.get(port, 'service')} connection (port {port})"
                severity = "Medium"

            # Create alert dictionary
            alert = {
                'timestamp': datetime.now(),
                'device': device['name'],
                'external_ip': external_ip,
                'reason': reason,
                'severity': severity
            }

            alerts.append(alert)

        return alerts

###///###